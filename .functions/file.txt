#!/bin/zsh

function asciiart() {
    local file="$1"
    local width="${2:-80}"

    if [[ -z "$file" ]]; then
        _show_message "Usage: asciiart <image-file> [width]" "error"
        return 1
    fi

    if [[ ! -f "$file" ]]; then
        _show_message "File not found: $file" "error"
        return 1
    fi

    if command -v jp2a &>/dev/null; then
        jp2a --width="$width" --colors "$file"
        return $?
    fi

    _show_message "No ASCII image tool found. Install jp2a" "error"
    return 1
}

### PRINT ASCII ###########################################################

function ascii_demon() {
  echo -e "${colors[red]}
            .                                                      .
        .n                   .                 .                  n.
  .   .dP                  dP                   9b                 9b.    .
 4    qXb         .       dX                     Xb       .        dXp     t
dX.    9Xb      .dXb    __                         __    dXb.     dXP     .Xb
9XXb._       _.dXXXXb dXXXXbo.                 .odXXXXb dXXXXb._       _.dXXP
  9XXXXXXXXXXXXXXXXXXXVXXXXXXXXOo.           .oOXXXXXXXXVXXXXXXXXXXXXXXXXXXXP
  \`9XXXXXXXXXXXXXXXXXXXXX'~   ~\`OOO8b   d8OOO'~   ~\`XXXXXXXXXXXXXXXXXXXXXP'
    \`9XXXXXXXXXXXP' \`9XX'          \`98v8P'          \`XXP' \`9XXXXXXXXXXXP'
        ~~~~~~~       9X.          .db|db.          .XP       ~~~~~~~
                        )b.  .dbo.dP'\`v'\`9b.odb.  .dX(
                      ,dXXXXXXXXXXXb     dXXXXXXXXXXXb.
                     dXXXXXXXXXXXP'   .   \`9XXXXXXXXXXXb
                    dXXXXXXXXXXXXb   d|b   dXXXXXXXXXXXXb
                    9XXb'   \`XXXXXb.dX|Xb.dXXXXX'   \`dXXP
                     \`'      9XXXXXX(   )XXXXXXP      \`'
                              XXXX X.\`v'.X XXXX
                              XP^X'\`b   d'\`X^XX
                              X. 9  \`   '  P )X
                              \`b  \`       '  d'
                               \`             '
 ${colors[reset]}"
}


#!/bin/zsh

### Colors ##########################################################################################################################

declare -A colors=(
  [green]='\033[0;32m'
  [red]='\033[0;31m'
  [blue]='\033[0;34m'
  [yellow]='\033[0;33m'
  [purple]='\033[0;35m'
  [turquoise]='\033[0;36m'
  [gray]='\033[0;37m'
  [magenta]='\033[0;35m'
  [cyan]='\033[0;36m'
  [black]='\033[0;30m'
  [white]='\033[0;97m'
  [reset]='\033[0m'
)

### Functions Privades #######################################################################################################

function _ctrl_c(){
  echo -e "\n\n${colors[red]}[!] ${colors[yellow]}Exiting...${colors[reset]}\n"
  tput cnorm; exit 1
}

function _calcSpaces() {
  local text=$1
  local maxlen=$2
  local lenText=${#text}
  local spaces=$(( maxlen - lenText ))

  if (( spaces > 0 )); then
    printf "%s%*s" "$text" "$spaces" ""
  else
    echo "${text[1,maxlen]}"
  fi
}

function _show_message() {
  local message="$1"
  local symbol="${2:-plus}"
  local extra="$3"

  case "$symbol" in
    error)
      echo -e "\n\n${colors[red]}[!] ${colors[yellow]}$message ${colors[white]}$extra${colors[reset]}\n"
      ;;
    inverse_error)
      echo -e "\n\n${colors[red]}[¡] ${colors[yellow]}$message ${colors[white]}$extra${colors[reset]}\n"
      ;;
    question)
      echo -e "\n${colors[blue]}[?] ${colors[green]}$message ${colors[white]}$extra${colors[reset]}\n"
      ;;
    inverse_question)
      echo -e "\n${colors[blue]}[¿] ${colors[green]}$message ${colors[white]}$extra${colors[reset]}\n"
      ;;
    info)
      echo -e "\n${colors[green]}[i] ${colors[cyan]}$message ${colors[red]}$extra${colors[reset]}\n"
      ;;
    minus)
      echo -e "\n${colors[yellow]}[-] ${colors[cyan]}$message ${colors[white]}$extra${colors[reset]}\n"
      ;;
    plus)
      echo -e "\n${colors[yellow]}[+] ${colors[cyan]}$message ${colors[white]}$extra${colors[reset]}\n"
      ;;
    euro)
      echo -e "\n${colors[green]}[€] ${colors[cyan]}$message ${colors[yellow]}$extra€ ${colors[reset]}"
      ;;
    dollar)
      echo -e "\n${colors[green]}[$] ${colors[cyan]}$message ${colors[yellow]}$extra$ ${colors[reset]}"
      ;;
    asterisk)
      echo -e "\n${colors[purple]}[*] ${colors[pink]}$message ${colors[cyan]}$extra${colors[reset]}"
      ;;
  esac
}
#!/bin/zsh

### HACKING Functions #####################################################

# Extracte de dominis d'un arxiu
function extractDomains() {
    # Extreu dominis dels URL en un fitxer i els desa a 'domains.txt'
    grep -oP '(?<=://)[^/]*' "$1" | sort -u | tee domains.txt
    echo "[*] Dominis guardats a domains.txt"
}

# Whois per cada domini en un fitxer
function whoisall() {
    # Fa un 'whois' per a cada domini en un fitxer i mostra només les primeres línies
    while read -r domain; do
        echo -e "\n--- $domain ---"
        whois "$domain" | head -n 20
    done < "$1"
}

# Identifica els tipus de hash en un fitxer
function hashidall() {
    # Detecta tipus de hash per a cada línia d'un fitxer
    while read -r hash; do
        echo -e "\n[+] $hash"
        hashid -m "$hash"
    done < "$1"
}

### S4vitar Functions ######################################################

# Make Tree
function mkt(){
	mkdir nmap content exploits scripts
}

function rmk(){
	scrub -p dod $1
	shred -zun 10 -v $1
}

# Extract nmap information
function extractPorts(){
	ports="$(cat $1 | grep -oP '\d{1,5}/open' | awk '{print $1}' FS='/' | xargs | tr ' ' ',')"
	ip_address="$(cat $1 | grep -oP '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' | sort -u | head -n 1)"
	echo -e "\n[*] Extracting information...\n" > extractPorts.tmp
	echo -e "\t[*] IP Address: $ip_address"  >> extractPorts.tmp
	echo -e "\t[*] Open ports: $ports\n"  >> extractPorts.tmp
	echo $ports | tr -d '\n' | xclip -sel clip
	echo -e "[*] Ports copied to clipboard\n"  >> extractPorts.tmp
	cat extractPorts.tmp; rm extractPorts.tmp
}

function scanPorts() {
    local host="${1:-127.0.0.1}"
    local start_port="${2:-1}"
    local end_port="${3:-1024}"

    _show_message "Starting port scan on $host ports $start_port-$end_port..." "info"
    tput civis

    trap _ctrl_c INT

    for port in $(seq $start_port $end_port); do
        (echo > /dev/tcp/"$host"/"$port") 2>/dev/null && echo "[+] $port - OPEN" &
    done

    wait
    tput cnorm
    _show_message "Port scan finished." "info"
}

### scanNet: escaneja hosts actius a una subxarxa (per defecte 192.168.1.x) 

function scanNet() {
    local subnet="${1:-192.168.1}"
    _show_message "Starting network scan on $subnet.1-254..." "info"
    trap _ctrl_c INT

    for i in $(seq 1 254); do
        timeout 1 bash -c "ping -c 1 $subnet.$i &>/dev/null" && echo "[+] Host $subnet.$i - ACTIVE" &
    done

    wait
    _show_message "Network scan finished." "info"
}

# fzf improvement
function fzf-lovely(){

	if [ "$1" = "h" ]; then
		fzf -m --reverse --preview-window down:20 --preview '[[ $(file --mime {}) =~ binary ]] &&
 	              echo {} is a binary file ||
	               (bat --style=numbers --color=always {} ||
	                highlight -O ansi -l {} ||
	                coderay {} ||
	                rougify {} ||
	                cat {}) 2> /dev/null | head -500'

	else
	      fzf -m --preview '[[ $(file --mime {}) =~ binary ]] &&
	                       echo {} is a binary file ||
	                       (bat --style=numbers --color=always {} ||
	                        highlight -O ansi -l {} ||
	                        coderay {} ||
	                        rougify {} ||
	                        cat {}) 2> /dev/null | head -500'
	fi
}
_core.zsh:
  info: "These are internal utility functions used to enhance other modules."
  functions:
    ctrl_c:
      description: "Handles Ctrl+C and exits cleanly"
    show_message:
      description: "Displays colored status/info messages with symbols"
    calcSpaces:
      description: "Calculates spaces for text alignment"

ascii_art.zsh:
  functions:
    ascii_demon:
      description: "Prints a red ASCII demon"
    asciiart:
      description: "Converts images to ASCII banners"

hacking.zsh:
  functions:
    extractDomains:
      description: "Extracts domains from URLs in a file"
    whoisall:
      description: "WHOIS lookup for domains"
    hashidall:
      description: "Detects hash types from a file"

net_utils.zsh:
  functions:
    ifaces:
      description: "Show network interfaces info (IP, MAC, public IP)"
    settarget:
      description: "Save target IP and name"
    cleartarget:
      description: "Clear saved target info"
    scanPorts:
      description: "TCP port scanner"
    scanNet:
      description: "Ping sweep on subnet"
    chintnm:
      description: "Rename network interface"
    connections:
      description: "Show active network connections"

notes.zsh:
  functions:
    remember:
      description: "Save a note with a timestamp"
    notes:
      description: "View all saved notes"
    clear_notes:
      description: "Clear all notes with confirmation"

wallpapers.zsh:
  functions:
    set_wallpaper:
      description: "Set wallpaper from ~/Pictures/Wallpapers"
#!/bin/zsh

trap _ctrl_c INT

# Help function compatible with Python yq (jq syntax)
function help() {
    local HELP_YAML="$HOME/.functions/_help.yaml"
    
    # Check dependencies
    if ! command -v yq &> /dev/null; then
        _show_message "yq is required but not installed." "error"
        _show_message "Install with:\nDebian: sudo apt install yq\nArch: pacman -S yq" "info"
        return 1
    fi
    
    if [[ ! -f "$HELP_YAML" ]]; then
        _show_message "Help file not found:" "error" "$HELP_YAML"
        _show_message "Make sure your _help.yaml file exists in the correct location." "info"
        return 1
    fi
    
    # Test YAML parsing with Python yq (jq syntax)
    local yq_test
    yq_test=$(yq 'keys' "$HELP_YAML" 2>&1)
    if [[ $? -ne 0 ]]; then
        _show_message "Invalid YAML format in" "error" "$HELP_YAML"
        _show_message "YQ Error:" "info" "$yq_test"
        return 1
    fi
    
    # Load modules with error handling (Python yq syntax)
    local my_modules
    my_modules=($(yq 'keys | .[]' "$HELP_YAML" 2>/dev/null | tr -d '\r' | tr -d '"'))
    
    if [[ ${#my_modules[@]} -eq 0 ]]; then
        _show_message "No modules found in help file" "error"
        return 1
    fi
    
    while true; do
        clear
        local header="$(_calcSpaces '    Welcome to the custom functions help panel' 52)"
        echo -e "${colors[purple]}┌────────────────────────────────────────────────────┐${colors[reset]}"
        echo -e "${colors[purple]}│${colors[cyan]}$header${colors[purple]}│${colors[reset]}"
        echo -e "${colors[purple]}└────────────────────────────────────────────────────┘${colors[reset]}"
        echo -e "${colors[green]}[?]${colors[reset]} ${colors[cyan]}Which module do you want to view?${colors[reset]}\n"
        
        # Print module list
        local i=1
        for module in "${my_modules[@]}"; do
            [[ -z "$module" ]] && continue  # Skip empty entries
            echo -e "${colors[yellow]} $(printf "%02d" $i))${colors[reset]} ${colors[blue]}$module${colors[reset]}"
            ((i++))
        done
        
        echo -ne "\n${colors[green]}➤${colors[reset]} ${colors[cyan]}Select module number (q to quit):${colors[reset]} "
        read choice
        
        [[ "$choice" =~ ^[Qq]$ ]] && return 0
        
        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#my_modules[@]} )); then
            _show_module "${my_modules[$choice]}" "$HELP_YAML"
        else
            _show_message "Invalid selection." "error"
        fi
        
        _show_message "Press ENTER to return to the menu..." "plus"
        read
    done
}

# Show module function compatible with Python yq
function _show_module() {
    local module="$1"
    local HELP_YAML="$2"
    
    # Verify module exists (Python yq syntax)
    if ! yq "has(\"$module\")" "$HELP_YAML" 2>/dev/null | grep -q "true"; then
        _show_message "Module '$module' not found!" "error"
        return 1
    fi
    
    clear
    echo -e "${colors[yellow]}Module: ${colors[cyan]}$module${colors[reset]}\n"
    
    # Get functions with Python yq syntax
    local funcs_list
    funcs_list=$(yq ".\"$module\".functions // {} | keys | .[]" "$HELP_YAML" 2>/dev/null | tr -d '"')
    
    if [[ -n "$funcs_list" ]]; then
        while IFS= read -r func_name; do
            [[ -z "$func_name" ]] && continue
            local desc=$(yq ".\"$module\".functions.\"$func_name\".description" "$HELP_YAML" 2>/dev/null | tr -d '"')
            echo -e "  ${colors[green]}$func_name${colors[reset]} → $desc"
        done <<< "$funcs_list"
    else
        _show_message "No functions found for this module" "error"
    fi
    
    # Optional info message
    local info
    info=$(yq ".\"$module\".info // \"\"" "$HELP_YAML" 2>/dev/null | tr -d '"')
    [[ -n "$info" && "$info" != "null" ]] && _show_message "$info" "info"
}
#!/bin/zsh

function ifaces() {
    local c="${colors[@]}"  # només per posar aquí, no cal fer servir

    show_help() {
        echo -e "\n${colors[cyan]}ifaces help menu${colors[reset]}"
        echo -e "  ${colors[green]}-i${colors[reset]}   →  Show all interfaces"
        echo -e "  ${colors[green]}-I${colors[reset]}   →  Show active interfaces with IP"
        echo -e "  ${colors[green]}-M${colors[reset]}   →  Show MAC addresses of interfaces"
        echo -e "  ${colors[green]}-A${colors[reset]}   →  Show interfaces with IP and MAC"
        echo -e "  ${colors[green]}-p${colors[reset]}   →  Ask and show public IP address\n"
    }

    case "$1" in
        -I)
            echo
            ip -o -4 addr show | while read -r _ iface _ addr _; do
                ip_addr=${addr%%/*}
                printf "${colors[green]}%-10s${colors[reset]} ${colors[blue]}%s${colors[reset]}\n" "$iface:" "$ip_addr"
            done
            echo
            ;;
        -i)
            echo
            ip -o link show | awk -v g="${colors[green]}" -v r="${colors[reset]}" '{printf "%s%s%s\n", g, $2, r}' | sed 's/://'
            echo
            ;;
        -M)
            echo
            ip link show | awk -v g="${colors[green]}" -v m="${colors[magenta]}" -v r="${colors[reset]}" '
                /^[0-9]+: / { iface=$2; gsub(":", "", iface) }
                /link\/ether/ { printf "%s%-10s%s %s%s%s\n", g, iface ":", r, m, $2, r }'
            echo
            ;;
        -A)
            echo
            ip -o link show | while read -r _ iface _; do
                iface=${iface%:}
                mac=$(ip link show "$iface" | awk '/link\/ether/ {print $2}')
                ip=$(ip -4 -o addr show "$iface" | awk '{print $4}' | cut -d/ -f1)
                printf "${colors[green]}%-10s${colors[reset]} ${colors[blue]}%-15s${colors[reset]} ${colors[magenta]}%s${colors[reset]}\n" "$iface:" "${ip:-–}" "${mac:-–}"
            done
            echo
            ;;
        -p)
            echo -ne "\n${colors[cyan]}Show public IP? (y/N): ${colors[reset]}"
            read -r answer
            if [[ "$answer" =~ ^[Yy]$ ]]; then
                ip_publica=$(curl -s https://api.ipify.org)
                echo -e "\n${colors[green]}Public IP:${colors[reset]} ${colors[blue]}${ip_publica}${colors[reset]}\n"
            fi
            ;;
        -h|"")
            show_help
            ;;
        *)
            show_help
            ;;
    esac
}

function connections() {
  _show_message "Showing active connections..." info

  # SSH Sessions (from 'who')
  ssh_sessions=$(who | grep -E '(\(|\bpts\b)')
  if [[ -n "$ssh_sessions" ]]; then
    echo -e "${colors[cyan]}── SSH Sessions ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────${colors[reset]}"
    echo "$ssh_sessions" | while read -r user tty date time ip; do
      ip_clean=${ip//[\(\)]/}
      [[ -z "$ip_clean" ]] && ip_clean="localhost"
      echo -e "${colors[green]}User:${colors[reset]} $user"
      echo -e "${colors[green]}Terminal:${colors[reset]} $tty"
      echo -e "${colors[green]}Time:${colors[reset]} $date $time"
      echo -e "${colors[green]}IP:${colors[reset]} $ip_clean"
      echo
    done
  fi

  # tmate sessions
  tmate_sessions=$(pgrep -af tmate)
  if [[ -n "$tmate_sessions" ]]; then
    echo -e "${colors[cyan]}── tmate Sessions (if any) ───────────────────────────────────────────────────────────────────────────────────────────────────────────────${colors[reset]}"
    echo "$tmate_sessions" | while read -r line; do
      echo -e "${colors[yellow]}$line${colors[reset]}"
    done
  fi

  # Active SSH network connections
  ssh_network=$(ss -tp | grep ssh)
  if [[ -n "$ssh_network" ]]; then
    echo -e "${colors[cyan]}── Active SSH Network Connections ────────────────────────────────────────────────────────────────────────────────────────────────────────${colors[reset]}"
    echo "$ssh_network" | while read -r line; do
      echo -e "${colors[magenta]}$line${colors[reset]}"
    done
  fi

  # Other active sessions from 'w'
  other_sessions=$(w -h | awk '{printf "%-10s %-10s %-10s %-15s\n", $1, $2, $3, $NF}')
  if [[ -n "$other_sessions" ]]; then
    echo -e "${colors[cyan]}── Other Active Sessions ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────${colors[reset]}"
    echo "$other_sessions" | while read -r u t l ip; do
      echo -e "${colors[blue]}User:${colors[reset]} $u ${colors[blue]}Terminal:${colors[reset]} $t ${colors[blue]}Login:${colors[reset]} $l ${colors[blue]}From:${colors[reset]} $ip"
    done
  fi
}

function chintnm() {
  trap _ctrl_c INT
  
  if [[ $# -ne 2 ]]; then
    _show_message "Usage: chintnm <old_name> <new_name>" error
    return 1
  fi

  local old_if=$1
  local new_if=$2

  # Comprovem si la interfície existeix
  if ! ip link show "$old_if" &>/dev/null; then
    _show_message "Interface $old_if not found" error
    return 1
  fi

  _show_message "Changing interface name from $old_if to $new_if..." info

  # Desactivem i canviem nom
  sudo ip link set "$old_if" down || {
    _show_message "Failed to bring $old_if down" error
    return 1
  }

  sudo ip link set "$old_if" name "$new_if" || {
    _show_message "Failed to rename $old_if to $new_if" error
    sudo ip link set "$old_if" up
    return 1
  }

  sudo ip link set "$new_if" up || {
    _show_message "Failed to bring $new_if up" error
    return 1
  }

  _show_message "Interface renamed successfully: $old_if → $new_if" plus
}
#!/bin/zsh

function remember() {
    local timestamp=$(date '+%d/%m/%Y %H:%M:%S')
    local message="$*"
    echo "$timestamp|$message" >> ~/.notes
    _show_message "Note saved:" plus "$message"
}

function notes() {
    if [[ ! -s ~/.notes ]]; then
        _show_message "You have no notes yet!" info
        return
    else
        echo -e "\n\n${colors[purple]}─── Notes ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────${colors[reset]}\n"
        grep '|' ~/.notes | while IFS='|' read -r datetime note; do
            local date_part="${datetime%% *}"    # date DD/MM/YYYY
            local time_part="${datetime#* }"     # time HH:MM:SS

            echo -e "${colors[yellow]}$date_part${colors[reset]} - ${colors[green]}$time_part${colors[reset]} | ${colors[cyan]} $note${colors[reset]}"
        done
        echo
    fi
}

function clear_notes() {
    if [[ ! -f ~/.notes ]] || [[ ! -s ~/.notes ]]; then
        _show_message "There is no notes file to clear." error
        return
    fi

    echo -ne "\n${colors[yellow]}Are you sure you want to delete all notes? (y/N) ${colors[reset]}\n" && read -r answer

    case "$answer" in
        [yY])
            echo "" > ~/.notes
            _show_message "All notes have been deleted." minus
            ;;
        *)
            _show_message "Action cancelled." info
            ;;
    esac
}
function batteryStatus() {
    local bat_device info percent bat_state color battery_lines i fill_level symbol

    # Get battery device
    bat_device=$(upower -e | grep -m1 'BAT')
    if [[ -z "$bat_device" ]]; then
        _show_message "Battery info not found!" "error"
        return 1
    fi

    # Get battery info
    info=$(upower -i "$bat_device")
    percent=$(echo "$info" | awk '/percentage/ {gsub(/%/,"",$2); print int($2)}')
    bat_state=$(echo "$info" | awk -F': ' '/state/ {gsub(/^[ \t]+|[ \t]+$/,"",$2); print $2}')

    if [[ -z "$percent" ]]; then
        _show_message "Could not read battery data!" "error"
        return 1
    fi

    # Set color based on percentage
    if (( percent >= 75 )); then
        color=${colors[green]}
    elif (( percent >= 40 )); then
        color=${colors[yellow]}
    else
        color=${colors[red]}
    fi

    # Thresholds for fill level (1–5 bars)
    if   (( percent >= 80 )); then fill_level=5
    elif (( percent >= 60 )); then fill_level=4
    elif (( percent >= 40 )); then fill_level=3
    elif (( percent >= 20 )); then fill_level=2
    else fill_level=1
    fi

    # Choose battery symbol (synced with thresholds)
    if (( percent >= 80 )); then
        symbol="🔋"
    elif (( percent >= 60 )); then
        symbol="🔋"
    elif (( percent >= 40 )); then
        symbol="🔋"
    elif (( percent >= 20 )); then
        symbol="🪫"
    else
        symbol="🪫"
    fi

    # Battery ASCII art (8 lines)
    battery_lines=(
        "  ╔══╗   "  # 1 top connector
        "╔═╩══╩═╗ "  # 2 cap
        "║      ║ "  # 3 fillable
        "║      ║ "  # 4 fillable
        "║      ║ "  # 5 fillable
        "║      ║ "  # 6 fillable
        "║      ║ "  # 7 fillable
        "╚══════╝ "  # 8 bottom
    )

    # Fill from bottom up (rows 7 → 3)
    for ((i = 0; i < fill_level; i++)); do
        battery_lines[$((7 - i))]="║██████║ "
    done

    # Print battery
    echo -e "\n${color}"
    for line in "${battery_lines[@]}"; do
        echo "$line"
    done

    # Battery info below
    echo -e "\n${symbol} ${percent}%"
    if [[ "${bat_state:l}" == "charging" ]]; then
        echo -e "⚡ Charging"
    elif [[ "${bat_state:l}" == "discharging" ]]; then
        echo -e "🔽 Discharging"
    elif [[ "${bat_state:l}" == "full" ]]; then
        echo -e "✅ Full"
    fi
    echo -e "${colors[reset]}"
}
function settarget() {
    ip_address=$1
    machine_name=$2

    # Si no s'especifica nom, s'usa "unknown"
    if [ -z "$machine_name" ]; then
        machine_name="unknown"
    fi

	echo "$ip_address $machine_name" > ~/.config/polybar/bin/target

    export TARGET="$ip_address"
    export TARGET_NAME="$machine_name"
    export T="$ip_address"
    export t="$ip_address"
}

# Neteja el target
function cleartarget() {
    > ~/.config/polybar/bin/target
    unset TARGET TARGET_NAME T t
}
#!/bin/zsh

function tetas(){
    list=(
        tetitas tetazas tetorras tetotas tetarracas tetacas tetuzas teturras tetungas tetillas
        bufas bufarras bufarracas bufoncias mamelungas mamelones melones domingas bubalongas babongas
        pechugas peras peritas perolas mamellas tetolas gemelas maracas bazucas petacas
    )

	for item in "${list[@]}"; do
        echo "$item"
        sleep 0.3
    done
}

function jagger() {
    feh --bg-scale /home/swany/Pictures/Wallpapers/.jagermeister.jpg &>/dev/null
}

function rr() {
      curl -s -L https://raw.githubusercontent.com/keroserene/rickrollrc/master/roll.sh | bash
}
#!/bin/zsh

### CONSTANTS #############################################################
TRASH_DIR="${HOME}/.trash"

# Ensure trash dir exists
if [[ ! -d "$TRASH_DIR" ]]; then
  mkdir -p "$TRASH_DIR"
fi

### MKCD ##################################################################

function mkcd() {
    if [[ -z "$1" ]]; then
        echo "Usage: mkcd <directory_name>"
        return 1
    fi

    mkdir -p "$1" && cd "$1" || return 1
}

### MAN (Manual) ##########################################################

man() {
  command man "$@" | col -bx | bat -l man -p
}

### Extract ###############################################################

function extract () {
    # Detecta el tipus d'arxiu i el descomprimeix
    if [ -f "$1" ]; then
        case "$1" in
            *.tar.bz2)   tar xjf "$1" ;;
            *.tar.gz)    tar xzf "$1" ;;
            *.bz2)       bunzip2 "$1" ;;
            *.rar)       unrar x "$1" ;;
            *.gz)        gunzip "$1" ;;
            *.tar)       tar xf "$1" ;;
            *.tbz2)      tar xjf "$1" ;;
            *.tgz)       tar xzf "$1" ;;
            *.zip)       unzip "$1" ;;
            *.Z)         uncompress "$1" ;;
            *.7z)        7z x "$1" ;;
            *)           echo "'$1' no es pot extreure amb extract()" ;;
        esac
    else
        echo "'$1' no és un arxiu vàlid"
    fi
}

### Backup ################################################################

function backup() {
    # Show help
    if [[ "$1" == "-h" || "$1" == "--help" ]]; then
        _show_message "Usage: backup <file_or_directory>
- For files: copies .bak in same dir and timestamped copy in ~/.backup
- For directories: copies .bak in same dir and compressed .zip in ~/.backup" "info"
        return 0
    fi

    # Check argument
    if [[ -z "$1" ]]; then
        _show_message "No file or directory specified" "error"
        return 1
    fi

    local target="$1"
    local timestamp=$(date +%Y-%m-%d_%H-%M-%S)
    local backup_dir="$HOME/.backup"

    # Create backup dir if not exists
    [[ ! -d "$backup_dir" ]] && mkdir -p "$backup_dir"

    if [[ -f "$target" ]]; then
        # File backup
        local base=$(basename "$target")
        local dir=$(dirname "$target")
        local bak_name="${base}_${timestamp}.bak"

        cp "$target" "$dir/$bak_name"
        cp "$target" "$backup_dir/$bak_name"

    elif [[ -d "$target" ]]; then
        # Directory backup
        local base=$(basename "$target")
        local dir=$(dirname "$target")
        local bak_name="${base}_${timestamp}.bak"
        local zip_name="${base}_${timestamp}.zip"

        cp -r "$target" "$dir/$bak_name"
        zip -r "$backup_dir/$zip_name" "$target" > /dev/null

    else
        _show_message "Target '$target' does not exist!" "error"
        return 1
    fi

    _show_message "Backup Completed" "plus"
}

### Copy Output from a file (CPUT) ########################################

function cput() {
    local file="$1"

    if [[ -z "$file" || ! -f "$file" ]]; then
        _show_message "File not found or not specified" "error"
        return 1
    fi

    # Detect clipboard command
    if command -v wl-copy &>/dev/null; then
        cat "$file" | wl-copy
        _show_message "File copied to clipboard" "plus"
    elif command -v xclip &>/dev/null; then
        cat "$file" | xclip -selection clipboard
        _show_message "File copied to clipboard" "plus"
    else
        _show_message "No clipboard command found (install wl-clipboard or xclip)" "error"
        return 1
    fi
}

### RM Function + Trash ###################################################

rm() {
  local OPTIND opt
  local files=()

  # Ensure trash directory exists
  if [[ ! -d "$TRASH_DIR" ]]; then
    mkdir -p "$TRASH_DIR"
  fi

  # Parse options but silently ignore -r and -f
  while getopts ":rf" opt; do
    case $opt in
      r|f)
        # Ignore -r and -f options silently
        ;;
      \?)
        echo "rm: invalid option -- $OPTARG"
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  files=("$@")

  if [[ ${#files[@]} -eq 0 ]]; then
    echo "rm: missing operand"
    return 1
  fi

  for f in "${files[@]}"; do
    if [[ -e "$f" ]]; then
      local base=$(basename -- "$f")
      local target="$TRASH_DIR/$base"
      # If target exists, add timestamp prefix
      if [[ -e "$target" ]]; then
        target="$TRASH_DIR/$(date +%s)_$base"
      fi
      mv -- "$f" "$target"
      if [[ $? -ne 0 ]]; then
        echo "rm: failed to move '$f' to trash"
      fi
    else
      echo "rm: cannot remove '$f': No such file or directory"
    fi
  done
}

### Remove ################################################################

# Function: permanently delete files from anywhere
remove() {
  if [ -z "$1" ]; then
    _show_message "Usage: remove <file>" "error"
    return 1
  fi

  _show_message "Are you sure you want to permanently delete" "info" "$* ${colors[yellow]}[y/N]${colors[cyan]}:"
  read -r confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    command rm -rf -- "$@"
    _show_message "Deleted permanently." "plus"
  else
    _show_message "Cancelled." "minus"
  fi
}

### Trash & ClearTrash ####################################################

trash() {
  if [ "$(ls -A "$TRASH_DIR" 2>/dev/null)" ]; then
    _show_message "Trash contents:" "info"
    ls -lh -- "$TRASH_DIR"
  else
    _show_message "Trash is empty." "minus"
  fi
}

# Function: empty the trash with confirmation
clear_trash() {
  if [ ! "$(ls -A "$TRASH_DIR" 2>/dev/null)" ]; then
    _show_message "Trash is already empty." "info"
    return
  fi

  _show_message "This will permanently delete ALL contents in the trash!" "error"
  printf "${colors[cyan]}Continue? ${colors[yellow]}[y/N]: ${colors[reset]}"
  read -r confirm
  if [[ "$confirm" =~ ^[Yy]$ ]]; then
    /bin/rm -rf -- "$TRASH_DIR"/*
    _show_message "Trash successfully emptied." "plus"
  else
    _show_message "Cancelled." "minus"
  fi
}
#!/bin/zsh

### Plex Media Server Auto Update #########################################

plexupdate() {
  local url="https://plex.tv/downloads/latest/5?channel=16&build=linux-x86_64&distro=debian&X-Plex-Token=xxxxxxxxxxxxxxxxxxxx"
  local file="/tmp/plexmediaserver_latest.deb"

  _show_message "Downloading the latest version of Plex Media Server..." info
  curl -L "$url" -o "$file"

  if [[ $? -ne 0 ]]; then
    _show_message "Failed to download Plex. Check your connection or token." error
    return 1
  fi

  _show_message "Installing the package..." plus
  sudo dpkg -i "$file"

  if [[ $? -ne 0 ]]; then
    _show_message "Error during installation." error
    return 1
  fi

  _show_message "Restarting Plex Media Server..." info
  sudo systemctl restart plexmediaserver

  if [[ $? -eq 0 ]]; then
    _show_message "Plex successfully updated and restarted!" plus
  else
    _show_message "Failed to restart Plex. Check the service status." error
  fi

  # Optional: delete the downloaded package
  rm -f "$file"
}

### Discord Update ########################################################

discordupdate() {
  local url="https://discord.com/api/download/stable?platform=linux&format=deb"
  local file="/tmp/discord_latest.deb"

  _show_message "Downloading the latest version of Discord..." info
  curl -L "$url" -o "$file"

  if [[ $? -ne 0 ]]; then
    _show_message "Failed to download Discord. Check your connection." error
    return 1
  fi

  _show_message "Installing the package..." plus
  sudo dpkg -i "$file"

  if [[ $? -ne 0 ]]; then
    _show_message "Error during installation." error
    return 1
  fi

  _show_message "Discord successfully updated!" plus

  rm -f "$file"
}
#!/bin/zsh

function set_wallpaper() {
  local wallpaper_dir="$HOME/Pictures/Wallpapers"
  local valid_exts=("jpg" "jpeg" "png" "webp" "bmp")
  local images=()

  for file in "$wallpaper_dir"/*; do
    local filename="${file:t}"
    local ext="${filename:e}"

    if [[ -f "$file" && "$filename" != .* ]]; then
      for ext_allowed in "${valid_exts[@]}"; do
        if [[ "$ext" == "$ext_allowed" ]]; then
          images+=("$filename")
        fi
      done
    fi
  done

  if [[ ${#images[@]} -eq 0 ]]; then
    _show_message "No visible image wallpapers found!" error
    return 1
  fi

  # --- Amb argument: intentar posar-lo ---
  if [[ -n "$1" ]]; then
    local selected="$1"
    if [[ " ${images[@]} " == *" $selected "* ]]; then
      feh --bg-scale "$wallpaper_dir/$selected" &>/dev/null
      _show_message "Wallpaper '$selected' applied successfully!" info
    else
      _show_message "Wallpaper '$selected' not found!" error
      return 1
    fi
    return 0
  fi

  # --- Sense argument: menú interactiu ---
  _show_message "Available wallpapers (type name with extension):" info
  for img in "${(@u)images[@]}"; do
    echo -e "${colors[green]} - ${colors[cyan]}$img${colors[reset]}"
  done

  echo -ne "\n${colors[blue]}[?]${colors[green]} Enter wallpaper filename (with extension): ${colors[reset]}"
  read selected

  if [[ " ${images[@]} " == *" $selected "* ]]; then
    feh --bg-scale "$wallpaper_dir/$selected" &>/dev/null
    _show_message "Wallpaper '$selected' applied successfully!" info
  else
    _show_message "Wallpaper '$selected' not found!" error
    return 1
  fi
}


function reload_autosuggestions() {
  source /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
}
